# portfolio

I would like to share some projects from my software portfolio

The projects included in this list give an introduction to socket programming, graphics, object-oriented programming, object-oriented design, modular design, GUIs, cryptography, web design, web applications, shell scripting, command-line programs, desktop software, design patterns, cloud computing, the TCP/IP protocol stack, algorithms, assembly language, arm64 assembly, x86 assembly, interprocess communication, data structures, databases, object serialization and deserialization, number systems (hexadecimal, decimal, and binary), modular arithmetic, image processing, image editing, ASCII, Unicode, character encodings, REST APIs, multithreading, boolean logic, variables, functions, objects, classes, and many other topics in computer science

(I might also add, byte arithmetic, bit arithmetic, packets, etc)

I can organize my portfolio as a list of projects, and attach notes to each item in the list

You can find the list of projects below

1. [chat](https://github.com/ataylor89/chat)
    - This is an open-source chat server (kind of like an IRC server)
    - I was able to deploy it successfully to AWS cloud, and run it successfully on AWS cloud
    - It uses the RSA encryption algorithm to encrypt packets that are exchanged between client and server
    - It uses a custom protocol that is built ontop of the TCP protocol
    - It uses custom packets, and each custom packet is contained within the body of a larger TCP packet
    - It uses a file database (or a serial database) to store user accounts and user passwords
    - This project teaches us a lot about socket programming, packets, protocols, the TCP/IP stack, encryption, databases, etc
2. [Paint](https://github.com/ataylor89/Paint)
    - This is an open-source paint application (kind of like MS Paint on Microsoft Windows)
    - I think it serves as a very good introduction to graphics
    - It can serialize an image to file and deserialize a file to image
    - It uses a lot of math behind the scenes
    - It uses the Java Swing framework and draws brush strokes on a JPanel, which acts as a canvas
    - It has a menu bar with menu actions and a toolbar that lets the user choose tools like a brush, pen, eraser, etc
    - It allows the user to save an image as a pnt file (using a serialization algorithm) and export a pnt file to a png file
    - This project teaches us a lot about graphics, Java, Swing, serialization, deserialization, etc
3. [WordProcessor](https://github.com/ataylor89/WordProcessor)
    - This is an open-source word processor written in Java
    - It uses the Java Swing framework
    - It uses a JTextArea to display plain text
    - It has a cute class called ColorSample, which subclasses JButton, and creates an icon for choosing a foreground or background color
    - It has a class called PreferencesDialog, which subclasses JDialog, and creates a dialog for editing user preferences
    - It has a central class called WordProcessor, which subclasses JFrame, and builds the graphical user interface
    - It has settings (in the preferences dialog) for controlling font size, font name, foreground color, background color, etc
    - This project teaches us a lot about Java, Swing, and different Swing components (like JTextArea and JDialog)
4. [rsa](https://github.com/ataylor89/rsa)
    - This is an open-source implementation of the RSA encryption algorithm
    - The RSA encryption algorithm is an example of asymmetric key cryptography, which means that the encryption key is different from the decryption key
    - The RSA encryption algorithm is also an example of public key cryptography, which is really just a special case of asymmetric key cryptography, in which the encryption key is considered public and the decryption key is considered private
    - The RSA algorithm is very secure, and if the public key gets discovered, it cannot be used to decrypt messages, and a hacker must derive the private key from the public key in order to decrypt an encrypted message
    - In a symmetric key algorithm, like XOR, on the other hand, if a hacker discovers the encryption key, the hacker can use the encryption key to decrypt messages, since the encryption key and the decryption key are identical
    - The project contained within this repository uses a file called primetable.py to generate a prime table
    - The key generation algorithm chooses two distinct prime numbers, p and q, from the prime table
    - The key generation algorithm then calculates the (n, e, d) values based on p and q
    - n is the product of p and q; e is the encryption exponent; d is the decryption exponent
    - We use the formula c = m^e % n to calculate the cipher (c) for a Unicode code point (m)
    - We use the formula m = c^d % n to calculate the Unicode code point (m) for a cipher (c)
    - The formula c = m^e % n is used to encrypt a Unicode character
    - The formula m = c^d % n is used to decrypt a cipher
    - We loop through the characters in a string, encrypt each character, encode the cipher, and join the encodings to create an encrypted message (first we encrypt a code point and make it a cipher, then we encode the cipher, then we append the encoding to a string and the resulting string represents the encrypted message)
    - The rsa project uses a file called keytable.py to generate keys and add them to a key table
    - The project uses a file called keygen.py to generate a key pair (public and private) from the key table and write them to file
    - The encrypt.py module is used to encrypt a message given a public key
    - The decrypt.py module is used to decrypt an encrypted message given a private key
    - The util.py module has a method called power_mod_n which is used to efficiently calculate m^e % n and c^d % n
    - The project contained within this repository can be used to encrypt and decrypt messages using the RSA algorithm
    - This project teaches us a lot about public key cryptography, asymmetric key cryptography, and the RSA encryption algorithm
    - If Alice and Barbara want to exchange secure communications, then Alice gives Barbara her public key, and Barbara uses Alice's public key to encrypt her messages, and Barbara gives Alice her public key, and Alice uses Barbara's public key to encrypt her messages; then, Barbara uses her private key to decrypt Alice's messages, and Alice uses her private key to decrypt Barbara's messages
    - That's how it works... when Alice and Barbara exchange public keys, it is called a handshake, an RSA handshake
5. [xor](https://github.com/ataylor89/xor)
    - This is an open-source implementation of the XOR encryption algorithm
    - The XOR encryption algorithm is an example of symmetric key cryptography, which means that the encryption key is identical to the decryption key
    - The XOR algorithm is very secure, but if the key gets discovered, it can be used to decrypt your messages, so it's important to keep the key as secret as possible (i.e. only known to the least possible number of trusted parties)
    - For example, if Alice and Barbara exchange secret messages using XOR encryption, then both Alice and Barbara would have to know the key, but they can keep it a secret and not tell anyone else the key
    - The project contained within this repository uses a file called keygen.py to generate a random key of a specified length (e.g. 1024 bytes)
    - The project uses a file called xor.py to do the XOR encryption
    - The XOR encryption algorithm is based on the XOR operation
    - The XOR operation has the special property that a = (a xor b) xor b
    - This means we can encrypt a message twice to get the original message
    - For example, let encrypted_message = xor(message, key)
    - Let original_message = xor(encrypted_message, key)
    - Then it's necessarily true that message == original_message; we can verify this programmatically and we can also verify this using mathematical proof
    - So you see that... the RSA algorithm is based on prime numbers and their special properties... whereas the XOR algorithm is based on the XOR operation and its special properties
6. [rot13](https://github.com/ataylor89/rot13)
    - This is an open-source implementation of the rot13 encryption algorithm
    - rot13 is a rotation cipher
    - The rot13 algorithm rotates each alphabetic character in a message by 13 places in the alphabet, and wraps around when it reaches the end of the alphabet
    - There are 26 letters in the English alphabet, which means, if you apply rot13 to a message twice, you get the original message
    - In other words, rot13(rot13(message)) == message
    - This is reminiscent of XOR encryption; we can say that rot13 is a symmetric key algorithm just like XOR
    - It is important to know that the rot13 algorithm is not secure
    - A hacker can crack a rot13-encrypted message just by trying out the rot13 algorithm
    - So, just to summarize, the RSA and XOR algorithms are very secure, but the rot13 algorithm is not secure
    - Even though the rot13 algorithm is not secure, it is still very useful to know
    - I believe that many people from classical antiquity used rotation ciphers similar to rot13
    - It is also the case that... there are specific uses for rot13... like when you want to send a message that is easy to decrypt
    - In conclusion, the rot13 algorithm is an important part of our education in cryptography, just like the RSA and XOR algorithms
7. [rot88](https://github.com/ataylor89/rot88)
    - This is an open-source implementation of an encryption algorithm that I created called rot88
    - rot88 is a rotation cipher
    - The 88 in rot88 stands for 0x88000, which is half the size of the Unicode code space
    - The Unicode code space has 0x110000 code points, which comes out to over 1 million code points in decimal
    - rot88 is a lot like rot13, but instead of rotating a letter by 13 places, it rotates a Unicode character by 0x88000 places
    - First, you get the code point for a Unicode character; a code point is an integer value that maps to a character
    - Then, you add 0x88000 to the code point, and calculate the remainder modulo 0x110000
    - The result is the new code point, i.e. new_code_point = (original_code_point + 0x88000) % 0x110000
    - You look up the Unicode character for the new code point, and substitute this new character for the original character
    - You apply this algorithm repeatedly, until every character in the message has been processed, and every substitution has been made
    - The result is the encrypted or decrypted message
    - rot88 is a symmetric key algorithm just like XOR and rot13
    - In symmetric key algorithms like XOR, rot13, and rot88, the same algorithm is used for both encryption and decryption
    - I wanted to give another example of a rotation cipher; there are many popular rotation ciphers that have been used throughout history
    - rot88 is actually not a secure encryption algorithm
    - RSA and XOR are very secure encryption algorithms, but rot13 and rot88 are not secure
    - The rot88 algorithm is not secure because a hacker could just try rot88 on any encrypted message, and see if it works
    - At the same time, the rot88 algorithm is very useful to know
    - The rot88 algorithm teaches us about Unicode, character encodings, code points, and how they can be used to create an encryption algorithm
    - In case you're wondering, "What is ASCII?" ASCII is a 7-bit character set that supports 128 characters
    - ASCII is a subset of Unicode and it comprises the first 128 characters of Unicode
    - ASCII and Unicode are consistent for the first 128 characters (or code points)
    - Unicode is a much larger character set, that supports many world languages, and has over 1 million characters (or code points)
    - The letter 'a' is a character in the Unicode character set
    - The code point 97 maps to the letter 'a' in the Unicode lookup table
    - This really teaches you the difference between a character and a code point
    - When you see the letter 'a' appear on the pixels of your screen, you are looking at a glyph
    - The letter 'a' can be represented by different glyphs, depending on what font you are using
    - When you write the letter 'a' to a file, you write the the value 97 to file
    - The number 97 can be represented as 61 in hexadecimal or 1100001 in binary
    - We use numbers to store data, because ultimately, data gets stored as voltage signals (high or low) in adjacent memory cells
    - Data gets stored in an array of adjacent memory cells, and each memory cell has a voltage signal (high or low)
    - A high voltage signal gets interpreted as a 1, and a low voltage signal gets interpreted as a 0
    - So we actually convert text (like this) to numbers and then we convert numbers to voltage signals
    - When we read a file, we convert voltage signals to numbers and numbers to text, in a process called file decoding
    - When we write to a file, we convert text to numbers and numbers to voltage signals, in a process called file encoding
    - So we actually have to decode a text file before we read a text file
    - We also have to encode a text file, while writing it, or upon saving it
    - This is a long series of notes, but I wanted to spend some time talking about Unicode, character encodings, encoding a text file, decoding a text file, and the process of converting text to numbers to voltage signals, and vice versa, when reading or writing a file
8. [signal](https://github.com/ataylor89/signal)
    - This is an open-source suite of signaling programs written in C and assembly
    - The signaling programs from this software suite can be used to stop, resume, or terminate an existing process
    - For example, the command `sigstop 2357` stops the process with process ID 2357
    - The command `sigcont 2357` resumes the process with process ID 2357
    - The command `sigterm 2357` terminates the process with process ID 2357
    - The source code in the arm folder is meant for a computer that has an ARM64 instruction set architecture
    - The source code in the x86 folder is meant for a computer that has an x86 instruction set architecture
    - My personal MacBook has an ARM64 architecture, so I use the code from the arm folder on my personal MacBook, and compile it on my personal MacBook, to create an executable that can be run on my personal MacBook
    - My server on AWS cloud has an x86-64 architecture, so I use the code from the x86 folder on my EC2 instance, and compile it on my EC2 instance, to create an executable that can be run on my EC2 instance
    - One of the things I really like about this project is that it teaches us about system calls
    - A system call (or syscall) is a request made by a program to the operating system's kernel to perform a task or service
    - A system call can be granted or denied by the kernel
    - A system call corresponds to a specific kernel function identified by its call number
    - The kernel of an operating system is the core part of the operating system
    - The system call API (or syscall API) corresponds to a set of kernel functions identified by their call numbers
    - On my Apple M1 chip, register x16 is used to hold the system call number
    - On my Apple M1 chip, registers x0 and x1 are used to hold the first two arguments to a system call
    - You can see in arm/sigterm.s, that register x0 holds the process ID, register x1 holds the signal number, and register x16 holds the system call number
    - To make a long story short, the signal repository contains a set of programs that can be used to stop, resume, or terminate an existing process, and it uses assembly language to make a system call
    - This project teaches us about C, assembly, system calls, the operating system kernel, user programs, kernel mode, user mode, how we can use assembly language to make system calls, and how we can use system calls to interact with the operating system
    - It's worth mentioning that, in the arm64 instruction set architecture, the svc instruction is used to make a system call, and in the x86 instruction set architecture, the syscall instruction is used to make a system call
    - I really enjoy writing assembly language because it teaches me how a computer works
9. [homepage](https://github.com/ataylor89/homepage)
    - This is an open source web application that is written in Python
    - It leverages the Flask web framework to route, handle, and respond to HTTP requests (like GET requests and POST requests)
    - It can be run locally (e.g. on a MacBook), on a web host, or on the cloud (e.g. on an EC2 instance in AWS cloud)
    - I run it locally and I also run it on an EC2 instance in AWS cloud
    - In my opinion, the word "cloud" is a computer science term that means "internet"... cloud is a metaphor for the internet
    - The project is organized according to a common Flask paradigm...
    - The HTML templates are stored in homepage/templates
    - The JavaScript code is stored in homepage/static/js
    - The CSS code is stored in homepage/static/css
    - I also put data files (like dictionary.json and 2025.json) in the homepage/static/data directory
    - Flask uses the Jinja templating language to render the HTML templates stored in homepage/templates before returning them to the HTTP client
    - This means that the HTML templates can make use of server-side Python variables... the HTML templates are dynamic
    - For example, the cryptography.html template makes use of a server-side Python variable to define its list of key names for a particular encryption algorithm (the key names are options in a select element)
    - Flask is fundamental to this project, because it's a very powerful web framework that lets you build elegant web applications
    - The homepage project has three external dependencies: Flask, requests, and geopy
    - The Flask framework allows us to create a Flask object, which can be run as a web server
    - The Flask framework also provides us with decorator methods (like @app.route) which allow us to route HTTP requests to a Python method of our choice (e.g. the '/' URL is routed to the home method in views.py)
    - The requests library is a second dependency and it is used in homepage/weather.py
    - We use the requests library to make GET requests to api.weather.gov
    - The response from api.weather.gov contains weekly weather data for a specific longitude and latitude
    - I think that weather.py is the only module that uses the requests library at the present moment in time
    - The geopy library is a third dependency and it is also used in homepage/weather.py
    - We use the geopy library to convert place names (like Mt. Everest) to coordinates (longitude and latitude)
    - After converting a place name to coordinates, we can get weather data for that place by issuing a GET request to api.weather.gov
    - The process of converting a place name to coordinates is often called geocoding
    - geopy is a geocoding library, and we use it for that purpose
    - You can see that, at the present moment in time, homepage has three external dependencies: Flask, requests, and geopy
    - I wanted homepage to be a "no setup" web application... so there is very little setup required
    - The external dependencies can be installed by running the command `pip install -r requirements.txt` in the project root directory
    - After the dependencies are installed, the web server can be started by running the command `python main.py` from the project root directory
    - After the web server has started, you can open the web page by visiting 127.0.0.1 or localhost in a web browser
    - localhost is a hostname that gets resolved to 127.0.0.1 (you can see this mapping in /etc/hosts on MacOS)
    - The homepage application bundles HTML, JavaScript, and CSS code with Python code
    - The Python code stays on the server, but the HTML, JavaScript, and CSS code get shipped to the browser
    - When the web browser makes a GET request for the index page, the web server produces a GET response which contains the index.html file
    - In this way, by means of GET requests, the web content (.html, .js, and .css) is shipped to the web browser
    - The server also has web services that can be called by making a GET or POST request to a specific endpoint
    - The web services often return data in JSON form (JSON stands for JavaScript Object Notation and it's a common data format)
    - For example, the weather.html page calls a web service to retrieve weather data for a specific place, by making a POST request to the /weather_data endpoint
    - The place name or coordinates are supplied as form data in the POST request
    - So you can see that the homepage webapp has a rich HTTP API that supports many features
    - You might ask, "Is it a RESTful API?"
    - At the present moment, I think it qualifies to be a RESTful API
    - But in the future, I would like to add logins, registrations, and sessions
    - When I add logins and sessions, the API will no longer be stateless
    - I think that an HTTP API has to be stateless in order to be a REST API
    - The current HTTP API is stateless... but when I add logins and sessions, it will no longer be stateless
    - It is very useful to learn how to build a web server and a web API
    - The homepage repository is a good example of a web server and a web API
    - A web server can be used to serve a web page to a web browser
    - A web server can also be used to define an HTTP API that can be called by an HTTP client
    - A web browser is just one example of an HTTP client...
    - There are REST clients out there that are specifically designed to interact with REST APIs
    - You can write your own HTTP client by writing a Python application that leverages the requests module (the requests module can be used to make HTTP requests like GET and POST and then store the HTTP response as an object)
    - In the chat project, we create a chat server built on TCP
    - In the homepage project, we create an HTTP server built on TCP, and the Flask framework does all the heavy lifting for us
    - Another popular web framework that allows you to build an HTTP server is Django
    - Flask and Django are two popular Python libraries that allow you to build an HTTP server
    - Technically, you could write Python code that builds a web server from scratch, but this would take a lot of time
    - The Flask framework takes care of all the technical details, and builds a web server for you
    - I think this is a good stopping point...
    - The homepage application is a great example of a web application written in Python
    - It leverages the Flask framework, which allows us to build a web server
    - If you want to write a web application in Java, you can leverage the Spring framework to build a web application
    - The Spring framework lets you route URLs and handle requests just like Flask and Django
    - There is also a C++ library called Crow which lets you build a web application or web services in C++
    - Most programming languages have a framework that simplifies the building of web applications or web services
    - I am very familiar with Flask, so I like to use Flask to write web applications in Python
    - The homepage webapp is easily extensible... it is easy to add new web pages, new features, new functionalities
    - So far I have added the index page, the weather page, the calendar page, the cryptography page, and the dictionary page
    - In the future, I would like to add more features and functionalities
    - Thanks for reading
    - Today is Tuesday, November 4, 2025
    - I have a lot planned for today so I'm going to end on this note
10.  [md5] (https://github.com/ataylor89/md5) and [sha-256] (https://github.com/ataylor89/sha256)
    - The MD5 and SHA-256 hashing algorithms are closely related, so I can include these two projects as a single item
    - MD5 stands for Message Digest 5 (presumably, version 5) and SHA-256 stands for Secure Hashing Algorithm 256 bits
    - The 256 in SHA-256 means that the message digest (or hash value) is 256 bits long, which is equivalent to 32 bytes
    - The MD5 message digest (or hash value), on the contrary, is 128 bits long, which is equivalent to 16 bytes
    - In other words, a SHA-256 message digest is twice as long as an MD5 message digest
    - The MD5 and SHA-256 hashing algorithms have many similarities
    - For one, they process their message in 64-byte blocks
    - For another, they pad a message before processing it, using a very similar padding algorithm
    - The MD5 algorithm uses four variables (A, B, C, and D) to create a final password hash
    - The SHA-256 algorithm uses eight variables (H1 through H8) to create a final password hash
    - These algorithms process a message in 64-byte blocks, and update their variables on each iteration
    - In the MD5 algorithm, the variables A, B, C, and D are words, and they are concatenated to produce a password hash
    - Similarly, in the SHA-256 algorithm, the variables H1 through H8 are words, and they are concatenated to produce a password hash
    - You might ask, "What is a word?"
    - A word is a unit of data, just like a byte is a unit of data
    - In mathematics, we say that a measurement is a number accompanied by a unit
    - 100 yards is a measurement, and it is equivalent to the length of a football field
    - 8 gigabytes is a measurement, and it is equivalent to the amount of memory in my computer
    - The meaning of the computer science term "word" depends on the context
    - In some contexts, a word is four bytes; in other contexts, a word is two bytes
    - Originally, a word referred to two bytes of data
    - With the advent of 64-bit processors, the term "word" came to refer to four bytes of data
    - We say that a word is a unit of data, and its length depends on the word size of a processor or the word size of an algorithm
    - In the context of the MD5 and SHA-256 algorithms, a word is four bytes of data
    - In the context of the earliest processors, a word is two bytes of data
    - In the context of the Apple M1 processor (which my computer runs on) a word is four bytes of data
    - So you can see that the word size depends on the context
    - The variables A, B, C, and D are words with a word size of four bytes, in the context of the MD5 algorithm
    - The variables H1 through H8 are words with a word size of eight bytes, in the context of the SHA-256 algorithm
    - I don't want to spend too much time laboring this point, but...
    - The MD5 algorithm really hinges on the output variables A, B, C, and D, which get modified with each iteration of processing, where a 64-byte block is processed, and the password hash that gets generated is the concentation of A, B, C, and D
    - The SHA-256 algorithm really hinges on the output variables H1 through H8, which get modified with each iteration of processing, where a 64-byte block of the padded message is processed, and the password hash that gets generated is the concentation of H1 through H8
    - Having talked about the algorithms in some detail, let's talk about why they are useful, and why we even need them in the first place
    - The MD5 and SHA-256 hashing algorithms have two main uses that I can think of
    - The first use case (or application) is for password security
    - It is a lot more secure to store a password hash in a server-side database than it is to store a plaintext password
    - If you store a plaintext password on a server, in a file or in a database, then there is a risk that someone who has access to the server will be able to open the file or the database and copy down the password
    - For example, if you store a plaintext password in /Users/myusername/passwords.txt, then anyone who can read that file can read your password and copy it down
    - If you store a plaintext password in a MySQL table, then anyone who has the privilege to read that table can read your password and copy it down
    - If you store a plaintext password in a file database (like a pickle file, a JSON file, or a file that stores a serialized object) then anyone who is able to read that file, or deserialize the object, can read your password and copy it down
    - It is far more secure to store a password hash
    - If you store a password hash on a server, in a file or in a database, then anyone who can read your password hash and copy it down is still ignorant of the password, because they have to crack the password hash before they discover the password
    - Is it easy to crack a password hash?
    - If you have a common password like "test" or "password" or "password123", then a hacker can lookup your password hash in a rainbow table and discover the password that corresponds to the password hash
    - But if you have a strong, random password, like `)*FDDFKJSDF^$*(\#%$UT&$($()\#\#)111!!!`, then it is very difficult for a hacker to find your password in a rainbow table, because they are very few rainbow tables that contain a password as strong as that one
    - A common practice is to salt a password before hashing it, to ensure that it is not a common password
    - When you salt a password, you turn a common password into an uncommon password, if the password is a common password
    - Salting a password means adding a random string before the start of the password
    - So if your password is "test123", then salting the password means adding a string before "test123"
    - You can assign a salt value to every user
    - If user "andrew" has a password of "test123", you can assign a salt value of "!\#%&(@$^*)135792" to the user "andrew"
    - Then, the password becomes "!\#%&(@$^*)135792test123"
    - The password has a random factor to it, and it is not a common password (whereas the original password test123 is very common)
    - So the salted password is "!\#%&(@$^*)135792test123", whereas the original password is "test123"
    - When you hash the salted password, using the SHA-256 algorithm, it produces a password hash that is very difficult to crack, because it is such a random and uncommon password that is hard to find a rainbow table that contains its password hash
    - In other words, salting a password makes the resulting password hash less vulnerable to rainbow table attacks
    - That is why we salt a password before hashing it... to make it more resistant to rainbow table attacks
    - Let's give an example
    - If I run the command `sha256 'test123'` using my Python script, I get a password hash of `ecd71870d1963316a97e3ac3408c9835ad8cf0f3c1bc703527c30265534f75ae`
    - If I run the command `sha256 '!\#%&(@$^*)135792test123'`, which uses the salted password, I get a password hash of `caffcbc8f6d577fc55534a9a38277c0da9a482267ee8c5c3eea701ec64aa9881`
    - The second password hash, which was generated from the salted password, is a lot less common, and it is a lot harder to crack
    - To make things crystal clear, I'll just say...
    - You can use the sha256 script I provided (or perhaps the /sbin/sha256 program if you have it) to generate a rainbow table of your own making... it can have two columns, password and password hash, and you can use it to crack a common a password hash
    - That really shows you how important it is to have a strong password
    - To make up for the fact that many people don't have a strong password, a secure web application uses password salting and password hashing to make a user's password secure
    - So even if a user chooses "test123" or "mypassword" as their password, the salting mechanism makes the password secure, because it adds a random string before the password, like `!\#%&(@$^*)135792`, which results in `!\#%&(@$^*)135792test123` or `!\#%&(@$^*)135792mypassword`, so that the final (salted) password is very hard to crack
    - But if you choose a password on a popular website, how do you know that they use password salting behind the scenes?
    - Almost all of them do, but just to be careful, it helps to have a strong password
    - I actually created a separate repository called "pwgen" which contains a script that generates a strong, random password
    - When I apply for jobs a company often asks me to create a new account and supply a username and a password
    - I recently created the pwgen.py script to generate strong, random passwords just for this reason
    - I have to be careful that I don't lose the password... I have many ways of saving the password
    - I think we are about ready to wrap things up for the MD5 and SHA-256 projects
    - One last thing
    - I said that the MD5 and SHA-256 algorithms can be used to enhance password security
    - There is another popular use case for these algorithms
    - They can also produce a checksum for a file, so that you are able to verify that the file you downloaded is equivalent to the file that is stored on the server
    - In other words, the source of the download (a server or something like that) provides a checksum, so that you can calculate the checksum for the downloaded file, and make sure it matches the checksum of the source
    - If the checksums match, then the downloaded file is (theoretically) exactly the same as the source's file
    - In other words, if the checksums match, then the downloaded file on your computer is exactly the same as the file on the server, at least, in theory
    - This helps you ensure that the file you download is exactly what it is meant to be... and that the data was not altered in transmission
    - When you download a file, it's actually the payload of a TCP packet
    - The TCP packet is actually the payload of an IP packet
    - All things start out as an IP packet... a TCP packet is contained within the payload of an IP packet
    - A downloaded file might be divided across several TCP packets
    - You can see that it actually takes some work to download a file... the file is transmitted in chunks and then the chunks are pieced together to create a unified file
    - The file is eventually stored on the hard drive under a unique path
    - To make sure that everything goes right, you can calculate the checksum for the downloaded file, and compare it with the server's checksum, to make sure that the two checksums match
    - I think this concludes our discussion of the MD5 and SHA-256 algorithms
    - The MD5 and SHA-256 algorithms can be used to enhance password security, and they can also be used to calculate checksums
    - In my chat repository, you can see that I salt a password and hash it using the SHA-256 algorithm, and then store it in a file database, so that way, if anyone has access to the file database, it is very hard for them to crack the password hash and figure out the password
    - I think that this is a common practice... many websites receive a password in plaintext, over an encrypted connection like https, and then salt the password, and hash it, and store the resulting password hash in a database
    - This is a good stopping point
    - So far I have included ten items in my portfolio, and the tenth item consists of two related projects
    - Will I add more to my portfolio? I don't know
    - Perhaps I will, but it is also the case that ten is a nice number
    - At the present moment, the portfolio contains a lot of work
    - It demonstrates how we can use Swing to write GUIs in Java
    - It demonstrates how we can use tkinter to write GUIs in Python
    - Swing is included in the Java standard (built-in) library
    - tkinter is included in the Python standard (built-in) library
    - A standard library is just a built-in library
    - I have used gtkmm to write GUIs in C++ on MacOS in the past
    - I have used gtk to write GUIs in C on MacOS in the past
    - C doesn't really have a built-in library for writing GUIs... and neither does C++
    - But Java and Python have built-in libraries for writing GUIs (Swing and tkinter, respectively)
    - The portfolio also shows how we can use the Flask web framework to write a web application in Python
    - Furthermore, it shows how we can use built-in socket libraries to write a chat server and a chat client in Python
    - The chat project is a tutorial on socket programming
    - The portfolio also provides a tutorial on encryption and password hashing
    - The rsa, xor, rot13, and rot88 projects are a tutorial on encryption
    - The md5 and sha256 projects are a tutorial on password hashing
    - The chat application gives a use case and an example of password salting (along with password hashing)
    - So I think that this portfolio covers many topics in computer science
    - The signal project shows how we can use C and assembly in combination to accomplish low-level tasks
    - I didn't want to forget the signal project... I wanted to include it
    - So as I said, the portfolio covers many topics in computer science, from GUIs, to web applications, to socket programming, to cryptography, to password hashing and password salting, to low-level programming in C and assembly
    - It also covers the two important topics of algorithms and data structures, which I explore more in other repositories
    - Now, I think we have reached a good stopping point
    - Sometimes I say that, and then I change my mind
    - But this time, I will really bring this series of notes to a conclusion
    - Today is Tuesday, November 25, 2025
    - Thanksgiving is just two days away
    - I spend Thanksgiving alone, and I also spend it eating vegan food
    - I eat vegan food every day
    - I am a vegan, an animal rights activist, and a plant rights activist
    - Animal rights are as important as civil rights
    - Hillary Clinton said "women's rights are human rights"
    - I say, "animal rights are human rights"
    - I also say, "animal rights are as important as civil rights"
    - I also say, "animal rights are women's rights"
    - I have many ways of saying it
    - Jesus said that many people are the salt of the Earth
    - Every animal is the salt of the Earth
    - And with that I wish you a happy holiday season
