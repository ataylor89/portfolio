# portfolio

I would like to share some projects from my software portfolio

The projects included in this list give an introduction to socket programming, graphics, object-oriented programming, object-oriented design, modular design, GUIs, cryptography, web design, web applications, shell scripting, command-line programs, desktop software, design patterns, cloud computing, the TCP/IP protocol stack, algorithms, assembly language, arm64 assembly, x86 assembly, interprocess communication, data structures, databases, object serialization and deserialization, number systems (hexadecimal, decimal, and binary), modular arithmetic, image processing, image editing, ASCII, Unicode, character encodings, REST APIs, multithreading, boolean logic, variables, functions, objects, classes, and many other topics in computer science

(I might also add, byte arithmetic, bit arithmetic, packets, etc)

I can organize my portfolio as a list of projects, and attach notes to each item in the list

You can find the list of projects below

1. [chat](https://github.com/ataylor89/chat)
    - This is an open-source chat server (kind of like an IRC server)
    - I was able to deploy it successfully to AWS cloud, and run it successfully on AWS cloud
    - It uses the RSA encryption algorithm to encrypt packets that are exchanged between client and server
    - It uses a custom protocol that is built ontop of the TCP protocol
    - It uses custom packets, and each custom packet is contained within the body of a larger TCP packet
    - It uses a file database (or a serial database) to store user accounts and user passwords
    - This project teaches us a lot about socket programming, packets, protocols, the TCP/IP stack, encryption, databases, etc
2. [Paint](https://github.com/ataylor89/Paint)
    - This is an open-source paint application (kind of like MS Paint on Microsoft Windows)
    - I think it serves as a very good introduction to graphics
    - It can serialize an image to file and deserialize a file to image
    - It uses a lot of math behind the scenes
    - It uses the Java Swing framework and draws brush strokes on a JPanel, which acts as a canvas
    - It has a menu bar with menu actions and a toolbar that lets the user choose tools like a brush, pen, eraser, etc
    - It allows the user to save an image as a pnt file (using a serialization algorithm) and export a pnt file to a png file
    - This project teaches us a lot about graphics, Java, Swing, serialization, deserialization, etc
3. [WordProcessor](https://github.com/ataylor89/WordProcessor)
    - This is an open-source word processor written in Java
    - It uses the Java Swing framework
    - It uses a JTextArea to display plain text
    - It has a cute class called ColorSample, which subclasses JButton, and creates an icon for choosing a foreground or background color
    - It has a class called PreferencesDialog, which subclasses JDialog, and creates a dialog for editing user preferences
    - It has a central class called WordProcessor, which subclasses JFrame, and builds the graphical user interface
    - It has settings (in the preferences dialog) for controlling font size, font name, foreground color, background color, etc
    - This project teaches us a lot about Java, Swing, and different Swing components (like JTextArea and JDialog)
4. [rsa](https://github.com/ataylor89/rsa)
    - This is an open-source implementation of the RSA encryption algorithm
    - The RSA encryption algorithm is an example of asymmetric key cryptography, which means that the encryption key is different from the decryption key
    - The RSA encryption algorithm is also an example of public key cryptography, which is really just a special case of asymmetric key cryptography, in which the encryption key is considered public and the decryption key is considered private
    - The RSA algorithm is very secure, and if the public key gets discovered, it cannot be used to decrypt messages, and a hacker must derive the private key from the public key in order to decrypt an encrypted message
    - In a symmetric key algorithm, like XOR, on the other hand, if a hacker discovers the encryption key, the hacker can use the encryption key to decrypt messages, since the encryption key and the decryption key are identical
    - The project contained within this repository uses a file called primetable.py to generate a prime table
    - The key generation algorithm chooses two distinct prime numbers, p and q, from the prime table
    - The key generation algorithm then calculates the (n, e, d) values based on p and q
    - n is the product of p and q; e is the encryption exponent; d is the decryption exponent
    - We use the formula c = m^e % n to calculate the cipher (c) for a Unicode code point (m)
    - We use the formula m = c^d % n to calculate the Unicode code point (m) for a cipher (c)
    - The formula c = m^e % n is used to encrypt a Unicode character
    - The formula m = c^d % n is used to decrypt a cipher
    - We loop through the characters in a string, encrypt each character, encode the cipher, and join the encodings to create an encrypted message (first we encrypt a code point and make it a cipher, then we encode the cipher, then we append the encoding to a string and the resulting string represents the encrypted message)
    - The rsa project uses a file called keytable.py to generate keys and add them to a key table
    - The project uses a file called keygen.py to generate a key pair (public and private) from the key table and write them to file
    - The encrypt.py module is used to encrypt a message given a public key
    - The decrypt.py module is used to decrypt an encrypted message given a private key
    - The util.py module has a method called power_mod_n which is used to efficiently calculate m^e % n and c^d % n
    - The project contained within this repository can be used to encrypt and decrypt messages using the RSA algorithm
    - This project teaches us a lot about public key cryptography, asymmetric key cryptography, and the RSA encryption algorithm
    - If Alice and Barbara want to exchange secure communications, then Alice gives Barbara her public key, and Barbara uses Alice's public key to encrypt her messages, and Barbara gives Alice her public key, and Alice uses Barbara's public key to encrypt her messages; then, Barbara uses her private key to decrypt Alice's messages, and Alice uses her private key to decrypt Barbara's messages
    - That's how it works... when Alice and Barbara exchange public keys, it is called a handshake, an RSA handshake
5. [xor](https://github.com/ataylor89/xor)
    - This is an open-source implementation of the XOR encryption algorithm
    - The XOR encryption algorithm is an example of symmetric key cryptography, which means that the encryption key is identical to the decryption key
    - The XOR algorithm is very secure, but if the key gets discovered, it can be used to decrypt your messages, so it's important to keep the key as secret as possible (i.e. only known to the least possible number of trusted parties)
    - For example, if Alice and Barbara exchange secret messages using XOR encryption, then both Alice and Barbara would have to know the key, but they can keep it a secret and not tell anyone else the key
    - The project contained within this repository uses a file called keygen.py to generate a random key of a specified length (e.g. 1024 bytes)
    - The project uses a file called xor.py to do the XOR encryption
    - The XOR encryption algorithm is based on the XOR operation
    - The XOR operation has the special property that a = (a xor b) xor b
    - This means we can encrypt a message twice to get the original message
    - For example, let encrypted_message = xor(message, key)
    - Let original_message = xor(encrypted_message, key)
    - Then it's necessarily true that message == original_message; we can verify this programmatically and we can also verify this using mathematical proof
    - So you see that... the RSA algorithm is based on prime numbers and their special properties... whereas the XOR algorithm is based on the XOR operation and its special properties
6. [rot13](https://github.com/ataylor89/rot13)
    - This is an open-source implementation of the rot13 encryption algorithm
    - rot13 is a rotation cipher
    - The rot13 algorithm rotates each alphabetic character in a message by 13 places in the alphabet, and wraps around when it reaches the end of the alphabet
    - There are 26 letters in the English alphabet, which means, if you apply rot13 to a message twice, you get the original message
    - In other words, rot13(rot13(message)) == message
    - This is reminiscent of XOR encryption; we can say that rot13 is a symmetric key algorithm just like XOR
    - It is important to know that the rot13 algorithm is not secure
    - A hacker can crack a rot13-encrypted message just by trying out the rot13 algorithm
    - So, just to summarize, the RSA and XOR algorithms are very secure, but the rot13 algorithm is not secure
    - Even though the rot13 algorithm is not secure, it is still very useful to know
    - I believe that many people from classical antiquity used rotation ciphers similar to rot13
    - It is also the case that... there are specific uses for rot13... like when you want to send a message that is easy to decrypt
    - In conclusion, the rot13 algorithm is an important part of our education in cryptography, just like the RSA and XOR algorithms
7. [rot88](https://github.com/ataylor89/rot88)
    - This is an open-source implementation of an encryption algorithm that I created called rot88
    - rot88 is a rotation cipher
    - The 88 in rot88 stands for 0x88000, which is half the size of the Unicode code space
    - The Unicode code space has 0x110000 code points, which comes out to over 1 million code points in decimal
    - rot88 is a lot like rot13, but instead of rotating a letter by 13 places, it rotates a Unicode character by 0x88000 places
    - First, you get the code point for a Unicode character; a code point is an integer value that maps to a character
    - Then, you add 0x88000 to the code point, and calculate the remainder modulo 0x110000
    - The result is the new code point, i.e. new_code_point = (original_code_point + 0x88000) % 0x110000
    - You look up the Unicode character for the new code point, and substitute this new character for the original character
    - You apply this algorithm repeatedly, until every character in the message has been processed, and every substitution has been made
    - The result is the encrypted or decrypted message
    - rot88 is a symmetric key algorithm just like XOR and rot13
    - In symmetric key algorithms like XOR, rot13, and rot88, the same algorithm is used for both encryption and decryption
    - I wanted to give another example of a rotation cipher; there are many popular rotation ciphers that have been used throughout history
    - rot88 is actually not a secure encryption algorithm
    - RSA and XOR are very secure encryption algorithms, but rot13 and rot88 are not secure
    - The rot88 algorithm is not secure because a hacker could just try rot88 on any encrypted message, and see if it works
    - At the same time, the rot88 algorithm is very useful to know
    - The rot88 algorithm teaches us about Unicode, character encodings, code points, and how they can be used to create an encryption algorithm
    - In case you're wondering, "What is ASCII?" ASCII is a 7-bit character set that supports 128 characters
    - ASCII is a subset of Unicode and it comprises the first 128 characters of Unicode
    - ASCII and Unicode are consistent for the first 128 characters (or code points)
    - Unicode is a much larger character set, that supports many world languages, and has over 1 million characters (or code points)
    - The letter 'a' is a character in the Unicode character set
    - The code point 97 maps to the letter 'a' in the Unicode lookup table
    - This really teaches you the difference between a character and a code point
    - When you see the letter 'a' appear on the pixels of your screen, you are looking at a glyph
    - The letter 'a' can be represented by different glyphs, depending on what font you are using
    - When you write the letter 'a' to a file, you write the the value 97 to file
    - The number 97 can be represented as 61 in hexadecimal or 1100001 in binary
    - We use numbers to store data, because ultimately, data gets stored as voltage signals (high or low) in adjacent memory cells
    - Data gets stored in an array of adjacent memory cells, and each memory cell has a voltage signal (high or low)
    - A high voltage signal gets interpreted as a 1, and a low voltage signal gets interpreted as a 0
    - So we actually convert text (like this) to numbers and then we convert numbers to voltage signals
    - When we read a file, we convert voltage signals to numbers and numbers to text, in a process called file decoding
    - When we write to a file, we convert text to numbers and numbers to voltage signals, in a process called file encoding
    - So we actually have to decode a text file before we read a text file
    - We also have to encode a text file, while writing it, or upon saving it
    - This is a long series of notes, but I wanted to spend some time talking about Unicode, character encodings, encoding a text file, decoding a text file, and the process of converting text to numbers to voltage signals, and vice versa, when reading or writing a file
8. [signal](https://github.com/ataylor89/signal)
    - This is an open-source suite of signaling programs written in C and assembly
    - The signaling programs from this software suite can be used to stop, resume, or terminate an existing process
    - For example, the command `sigstop 2357` stops the process with process ID 2357
    - The command `sigcont 2357` resumes the process with process ID 2357
    - The command `sigterm 2357` terminates the process with process ID 2357
    - The source code in the arm folder is meant for a computer that has an ARM64 instruction set architecture
    - The source code in the x86 folder is meant for a computer that has an x86 instruction set architecture
    - My personal MacBook has an ARM64 architecture, so I use the code from the arm folder on my personal MacBook, and compile it on my personal MacBook, to create an executable that can be run on my personal MacBook
    - My server on AWS cloud has an x86-64 architecture, so I use the code from the x86 folder on my EC2 instance, and compile it on my EC2 instance, to create an executable that can be run on my EC2 instance
    - One of the things I really like about this project is that it teaches us about system calls
    - A system call (or syscall) is a request made by a program to the operating system's kernel to perform a task or service
    - A system call can be granted or denied by the kernel
    - A system call corresponds to a specific kernel function identified by its call number
    - The kernel of an operating system is the core part of the operating system
    - The system call API (or syscall API) corresponds to a set of kernel functions identified by their call numbers
    - On my Apple M1 chip, register x16 is used to hold the system call number
    - On my Apple M1 chip, registers x0 and x1 are used to hold the first two arguments to a system call
    - You can see in arm/sigterm.s, that register x0 holds the process ID, register x1 holds the signal number, and register x16 holds the system call number
    - To make a long story short, the signal repository contains a set of programs that can be used to stop, resume, or terminate an existing process, and it uses assembly language to make a system call
    - This project teaches us about C, assembly, system calls, the operating system kernel, user programs, kernel mode, user mode, how we can use assembly language to make system calls, and how we can use system calls to interact with the operating system
    - It's worth mentioning that, in the arm64 instruction set architecture, the svc instruction is used to make a system call, and in the x86 instruction set architecture, the syscall instruction is used to make a system call
    - I really enjoy writing assembly language because it teaches me how a computer works
9. [homepage](https://github.com/ataylor89/homepage)
    - This is an open source web application that is written in Python
    - It leverages the Flask web framework to route, handle, and respond to HTTP requests (like GET requests and POST requests)
    - It can be run locally (e.g. on a MacBook), on a web host, or on the cloud (e.g. on an EC2 instance in AWS cloud)
    - I run it locally and I also run it on an EC2 instance in AWS cloud
    - In my opinion, the word "cloud" is a computer science term that means "internet"... cloud is a metaphor for the internet
    - The project is organized according to a common Flask paradigm...
    - The HTML templates are stored in homepage/templates
    - The JavaScript code is stored in homepage/static/js
    - The CSS code is stored in homepage/static/css
    - I also put data files (like dictionary.json and 2025.json) in the homepage/static/data directory
    - Flask uses the Jinja templating language to render the HTML templates stored in ${project_root}/templates before returning them to the HTTP client
    - This means that the HTML templates can make use of server-side Python variables... the HTML templates are dynamic
    - For example, the cryptography.html template makes use of a server-side Python variable to define its list of key names for a particular encryption algorithm (the key names are options in a select element)
    - Flask is fundamental to this project, because it's a very powerful web framework that lets you build elegant web applications
    - The homepage project has three external dependencies: Flask, requests, and geopy
    - The Flask framework allows us to create a Flask object, which can be run as a web server
    - The Flask framework also provides us with decorator methods (like @app.route) which allow us to route HTTP requests to a Python method of our choice (e.g. the '/' URL is routed to the home method in views.py)
    - The requests library is a second dependency and it is used in homepage/weather.py
    - We use the requests library to make GET requests to api.weather.gov
    - The response from api.weather.gov contains weekly weather data for a specific longitude and latitude
    - I think that weather.py is the only module that uses the requests library at the present moment in time
    - The geopy library is a third dependency and it is also used in homepage/weather.py
    - We use the geopy library to convert place names (like Mt. Everest) to coordinates (longitude and latitude)
    - After converting a place name to coordinates, we can get weather data for that place by issuing a GET request to api.weather.gov
    - The process of converting a place name to coordinates is often called geocoding
    - geopy is a geocoding library, and we use it for that purpose
    - You can see that, at the present moment in time, homepage has three external dependencies: Flask, requests, and geopy
    - I wanted homepage to be a "no setup" web application... so there is very little setup required
    - The external dependencies can be installed by running the command `pip install -r requirements.txt` in the project root directory
    - After the dependencies are installed, the web server can be started by running the command `python main.py` from the project root directory
    - After the web server has started, you can open the web page by visiting 127.0.0.1 or localhost in a web browser
    - localhost is a hostname that gets resolved to 127.0.0.1 (you can see this mapping in /etc/hosts on MacOS)
    - The homepage application bundles HTML, JavaScript, and CSS code with Python code
    - The Python code stays on the server, but the HTML, JavaScript, and CSS code get shipped to the browser
    - When the web browser makes a GET request for the index page, the web server produces a GET response which contains the index.html file
    - In this way, by means of GET requests, the web content (.html, .js, and .css) is shipped to the web browser
    - The server also has web services that can be called by making a GET or POST request to a specific endpoint
    - The web services often return data in JSON form (JSON stands for JavaScript Object Notation and it's a common data format)
    - For example, the weather.html page calls a web service to retrieve weather data for a specific place, by making a POST request to the /weather_data endpoint
    - The place name or coordinates are supplied as form data in the POST request
    - So you can see that the homepage webapp has a rich HTTP API that supports many features
    - You might ask, "Is it a RESTful API?"
    - At the present moment, I think it qualifies to be a RESTful API
    - But in the future, I would like to add logins, registrations, and sessions
    - When I add logins and sessions, the API will no longer be stateless
    - I think that an HTTP API has to be stateless in order to be a REST API
    - The current HTTP API is stateless... but when I add logins and sessions, it will no longer be stateless
    - It is very useful to learn how to build a web server and a web API
    - The homepage repository is a good example of a web server and a web API
    - A web server can be used to serve a web page to a web browser
    - A web server can also be used to define an HTTP API that can be called by an HTTP client
    - A web browser is just one example of an HTTP client...
    - There are REST clients out there that are specifically designed to interact with REST APIs
    - You can write your own HTTP client by writing a Python application that leverages the requests module (the requests module can be used to make HTTP requests like GET and POST and then store the HTTP response as an object)
    - In the chat project, we create a chat server built on TCP
    - In the homepage project, we create an HTTP server built on TCP, and the Flask framework does all the heavy lifting for us
    - Another popular web framework that allows you to build an HTTP server is Django
    - Flask and Django are two popular Python libraries that allow you to build an HTTP server
    - Technically, you could write Python code that builds a web server from scratch, but this would take a lot of time
    - The Flask framework takes care of all the technical details, and builds a web server for you
    - I think this is a good stopping point...
    - The homepage application is a great example of a web application written in Python
    - It leverages the Flask framework, which allows us to build a web server
    - If you want to write a web application in Java, you can leverage the Spring framework to build a web application
    - The Spring framework lets you route URLs and handle requests just like Flask and Django
    - There is also a C++ library called Crow which lets you build a web application or web services in C++
    - Most programming languages have a framework that simplifies the building of web applications or web services
    - I am very familiar with Flask, so I like to use Flask to write web applications in Python
    - The homepage webapp is easily extensible... it is easy to add new web pages, new features, new functionalities
    - So far I have added the index page, the weather page, the calendar page, the cryptography page, and the dictionary page
    - In the future, I would like to add more features and functionalities
    - Thanks for reading
    - Today is Tuesday, November 4, 2025
    - I have a lot planned for today so I'm going to end on this note
